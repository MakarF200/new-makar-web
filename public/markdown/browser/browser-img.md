# 浏览器如何处理图片？

最近在处理react的img的时候出现onload无法调用的问题，查阅了一些浏览器资料，干脆写成文档记录一下。

## 解析流程

### HTML解析阶段/JS执行阶段

当浏览器遇到一个图片标签 `<img>` 时，它会做以下事情：

1. 解析 `src` 属性，获取图片的 URL，并记录下来
2. 将该URL添加进资源请求队列
3. 根据浏览器的资源加载优先级，决定该资源的加载顺序，准备发起请求

### 发起请求阶段（Networking层）

1. DNS解析：浏览器会先解析图片的URL，获取对应的IP地址
2. TCP连接：浏览器会与服务器建立TCP连接，并发送HTTP请求
3. 缓存检查：如果浏览器有缓存，则会先检查缓存中是否有该资源的副本，如果有，则直接使用缓存的副本，不再发起请求
4. 发送HTTP请求：浏览器会发送一个HTTP请求，请求获取图片资源
   请求头中会包含：
   `  GET /path/to/image.jpg HTTP/1.1
Host: XXX.com
Accept: image/webp,image/*,*/*;q=0.8`
5. 服务器响应：服务器会返回HTTP响应，其中包含图片的二进制数据

### 图片解码阶段（Painting层）

1. 解码：浏览器会对图片的二进制数据进行解码，将其转换成像素数据
2. 根据文件格式，浏览器会选择相应的解码方式

   - JPEG → 熵编码 + DCT 逆变换
   - PNG → 无损压缩 + 解码过滤器
   - WebP/AVIF → 更复杂的块编码解压缩算法

3. 将解码后的结果存入 位图缓存（Decoded Bitmap Cache），这是一块内存中的像素矩阵（RGBA 数据）
4. 如果图片体积大或延迟解码（比如 loading="lazy"），浏览器会部分解码或推迟解码

### 渲染阶段（Compositing层）

1. layout阶段

- 若设置了width/height/aspect-ratio属性，可以提前占位
- 若没有设置这些，就需要等待图片的天然尺寸（如果没有提前占位，可能会导致页面布局错乱）

2. paint阶段
   位图解码完成，浏览器会将图片绘制到页面上
3. composite阶段
   GPU合成器将图片纹理上传到GPU（Texture Upload），进行合成显示

### 可见性优化与懒加载

- Lazy Loading
  如果图片距离可见区域很远，则可以设置 `loading="lazy"` 属性，浏览器会延迟加载图片，直到它出现在可见区域内（viewport）
- Intersection Observer
  对应JS的可见性检测机制，可以监听图片的进入和离开可见区域，进而触发懒加载
- HTTP/2 优先级调度
  HTTP/2 协议支持优先级调度，可以让浏览器更快地加载重要资源，比如图片
- 图片压缩
  压缩后的图片体积更小，加载速度更快，可以降低带宽成本

### 缓存层

图片加载完成后，浏览器会：

1. 原始图片数据缓存到磁盘缓存（ HTTP Cache ）
2. 解码后的图片数据缓存到内存缓存（ Decoded Bitmap Cache ）
3. 记录ETag、Last-Modified、Content-Length等元数据
   这样同一个URL的图片下次请求时：
4. 浏览器会先检查缓存，如果有缓存的副本，则直接使用缓存的副本，不再发起请求
5. 如果缓存过期，则会再次发起请求，获取最新的资源副本
6. 缓存的副本会被更新，并与原始资源进行比较，如果有变化，则会重新缓存

### 事件触发

当图片完成解码：
1.onload：图片加载完成触发该事件
2.onerror：图片加载失败触发该事件

## 流程图

`HTML 解析 / JS 创建 <img>
        ↓
加入资源加载队列
        ↓
网络层发请求 / 缓存命中
        ↓
数据返回
        ↓
解码线程池将字节流 → 位图
        ↓
Layout（确定尺寸）
        ↓
Paint（绘制图片）
        ↓
Composite（GPU合成）
        ↓
显示在屏幕上`
